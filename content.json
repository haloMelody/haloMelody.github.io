[{"title":"学习笔记-FastDFS","date":"2017-08-20T08:51:11.000Z","path":"2017/08/20/学习笔记-FastDFS/","text":"内容简介 在跟随项目实践过程中，代码中需要使用上传图片的功能，其中使用了FastDFS作为图片服务器，在此记录一下搭建FastDFS服务器的过程 框架介绍1.什么是FastDFS FastDFS是用c语言编写的一款开源的分布式文件系统。FastDFS为互联网量身定制，充分考虑了冗余备份、负载均衡、线性扩容等机制，并注重高可用、高性能等指标，使用FastDFS很容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务。 2.FastDFS架构 FastDFS架构包括 Tracker server和Storage server。客户端请求Tracker server进行文件上传、下载，通过Tracker server调度最终由Storage server完成文件上传和下载。 Tracker server作用是负载均衡和调度，通过Tracker server在文件上传时可以根据一些策略找到Storage server提供文件上传服务。可以将tracker称为追踪服务器或调度服务器。 Storage server作用是文件存储，客户端上传的文件最终存储在Storage服务器上，Storage server没有实现自己的文件系统而是利用操作系统 的文件系统来管理文件。可以将storage称为存储服务器,如下图： 3.Tracker 集群 FastDFS集群中的Tracker server可以有多台，Tracker server之间是相互平等关系同时提供服务，Tracker server不存在单点故障。客户端请求Tracker server采用轮询方式，如果请求的tracker无法提供服务则换另一个tracker。 4.Storage集群 Storage集群采用了分组存储方式。storage集群由一个或多个组构成，集群存储总容量为集群中所有组的存储容量之和。一个组由一台或多台存储服务器组成，组内的Storage server之间是平等关系，不同组的Storage server之间不会相互通信，同组内的Storage server之间会相互连接进行文件同步，从而保证同组内每个storage上的文件完全一致的。一个组的存储容量为该组内存储服务器容量最小的那个，由此可见组内存储服务器的软硬件配置最好是一致的。 采用分组存储方式的好处是灵活、可控性较强。比如上传文件时，可以由客户端直接指定上传到的组也可以由tracker进行调度选择。一个分组的存储服务器访问压力较大时，可 准备工作1.前提条件 安装好了VM+CentOs6.4（网络等配置都可正常使用）已安装nginx(非必须)JDK1.7 2.安装所需 fastdfs-nginx-module_v1.16.tar.gz - 集成nginx所需模块FastDFS_v5.05.tar.gz - FastDFS源码，C语言编写，需要手动编译jdk-7u67-linux-x64.tar.gznginx-1.8.0.tar.gz - nginx源码,C语言编写，需要手动编译libfastcommonV1.0.7.tar.gz - FastDFS官方提供的基础库perl-5.20.2.tar.gz - 编译基础库所需要的语言环境 服务搭建1.环境介绍 VM + CentOs6.4 + Jdk1.7 + nginx1.8.0 此处记录的是在同一台服务器上同时搭建tracker和storage,并且都是一个，组成的是一个最简便的集群环境。 2.安装libfastcommon基础库 将压缩包上传至虚拟机/usr/local下，解压缩 进入文件夹，看到有make.sh文件，执行 ./make.sh ,初次安装会报错，因为缺少必要的语言运行环境，执行下列命令 123456# FastDFS依赖libevent库，需要安装： yum -y install libevent# 安装gcc库,若之前安装过nginx，则不需要重复安装yum -y install gcc yum -y install gcc -c++ 安装Perl语言环境，需要下载源码perl-5.20.2.tar.gz,上传至/usr/local下，解压缩，进入目录，依次执行： 1234567$ tar -xzf perl-5.x.y.tar.gz //解压缩$ cd perl-5.x.y$ ./Configure -de$ make$ make test$ make install$ perl -v //检测是否安装成功 环境准备完成后再进入libfastcommon目录，执行 ./make.sh ，库会安装在/usr/lib64目录下，但是FastDFS设置的lib目录是/usr/local/lib ,所以此时可以有两种方式 123456# 第一种方式，复制一份cp /usr/lib64/libfastcommon.so /usr/local/lib # 第二种方式，建立软连接（推荐）ln -s /usr/lib64/libfastcommon.so /usr/local/lib/libfastcommon.so ln -s /usr/lib64/libfastcommon.so /usr/lib/libfastcommon.so 到此基础库安装完成 3.安装FastDFS 将FastDFS_v5.05.tar.gz拷贝至/usr/local/下,依次执行 1234tar -zxvf FastDFS_v5.05.tar.gzcd FastDFS./make.sh./make.sh install 如果安装过程中没有报错，并且在/etc/fdfs目录中包含配置文件，说明安装成功，随后将FastDFS目录下的conf下的文件拷贝到/etc/fdfs/下 4.配置tracker 前面所执行的步骤无论是tracker还是storage都是必须的，之后若要在不同的虚拟机上分别配置，主要就是对FastDFS安装完成之后的配置过程的不同，此处演示的是在同一台虚拟机上安装配置 初始化文件目录 12# 配置tracker所需要的base_pathmkdir /home/fastdfs_tracker 进入/etc/fdfs目录，复制tracker.conf.simple并改名为tracker.conf 编辑tracker.conf，对以下几个配置进行修改 123456# 是否启用此配置文件disabled = true # 端口号，一般使用这个默认端口port = 22122 # tracker的数据和日志文件目录（预先创建）base_path = /home/fastdfs_tracker 启动tracker,执行命令 1/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf restart 查看日志观察启动过程中是否报错 1tail -100f /home/fastdfs_tracker/logs/tracker.log (base_path路径) 启动没有问题，则设置tracker为开机自动启动,编辑：vi /etc/rc.d/rc.local ， 将此命令加入末行。至此，tracker安装完毕 5.配置storage 若更换虚拟机则需要执行以上的步骤，此处继续在原虚拟机上执行 初始化文件目录 1234# 配置storage所需要的base_path,保存日志信息mkdir /home/fastdfs_storage_info # 配置storage所需要的base_path,保存数据文件mkdir /home/fastdfs_storage_data 进入/etc/fdfs目录，复制storage.conf.simple并改名为storage.conf 编辑storage.conf，对以下几个配置进行修改 1234567891011121314# 是否启用此配置文件disabled = true # 组名group_name = group1# 端口,同一组必须保证端口统一port = 23001# 日志目录base_path = /home/fastdfs_storage_info# 存储路径个数，与组成员个数保持一致store_path_count = 1# 数据文件存储路径，果有多个挂载磁盘则定义多个store_path，后缀递增即可store_path0 = /home/fastdfs_storage_data# tracker服务器IP和端口，如果有多个则配置多个trackertracker_server = 192.168.XX.XXX:22122 启动storage,执行命令 1/usr/bin/fdfs_storaged /etc/fdfs/storage.conf restart 观察启动过程中是否报错 1234# 通过日志观察tail -100f /home/fastdfs_storage_info/logs/storaged.log# 通过监控观察是否成功注册到tracker/usr/bin/fdfs_monitor /etc/fdfs/storage.conf 启动没有问题，则设置storage为开机自动启动,编辑：vi /etc/rc.d/rc.local ， 将此命令加入末行。至此，storage安装完毕 6.测试服务 FastDFS安装成功可通过/usr/bin/fdfs_test测试上传、下载等操作。 编辑/etc/fdfs/client.conf，修改以下配置 12base_path=/home/fastdfs_trackertracker_server=192.168.XX.XXX:22122 使用格式：/usr/bin/fdfs_test 客户端配置文件地址 upload 上传文件,例如： 1/usr/bin/fdfs_test /etc/fdfs/client.conf upload test.jpg 上传后会打印返回信息，可以观察是否上传成功 http://192.168.XX.XXX/group1/M00/00/00/wKhlBVVY2M-AM_9DAAAT7-0xdqM485_big.png 就是文件的下载路径。 对应storage服务器上的：/home/fastdfs/fdfs_storage_data/data/00/00/wKhlBVVY2M-AM_9DAAAT7-0xdqM485_big.png文件。 由于现在还没有和nginx整合无法使用http下载 整合nginx 1.此处讨论的是在之前nginx上重新安装nginx（添加了新模块）的情况，如何安装nginx可以参考之前的博文：学习笔记-nginx 2.不管是在tracker上安装还是storage安装nginx，都需要先上传FastDFS-nginx-module模块，并且修改相应配置 3.tracker上安装nginx 在每个tracker上安装nginx，的主要目的是做负载均衡及实现高可用。此处只有一个tracker.为配置nginx 4.在storage上安装nginx 库环境在此处不再赘述，由于之前已经安装了nginx，此处需要添加新模块FastDFS-nginx-module，添加之前，先下载该模块并且修改相应的配置文件 上传FastDFS-nginx-module至/usr/java目录，解压缩，进入/FastDFS-nginx-module/src目录下，编辑config文件，将/usr/local改为/usr (将/local去掉) 12CORE_INCS=&quot;$CORE_INCS /usr/include/fastdfs /usr/include/fastcommon/&quot;CORE_LIBS=&quot;$CORE_LIBS -L/usr/lib -lfastcommon -lfdfsclient&quot; 将FastDFS-nginx-module/src下的mod_FastDFS.conf拷贝至/etc/fdfs/下,并且修改配置（类比按照自己实际情况修改）： 12345678910111213base_path = /home/fastdfs_storage_infotracker_server = XXstorage_server_port = XXgroup_name = XXurl_have_group_name = true #是否在url中使用组名store_path_count = 1store_path0 = /home/fastdfs_storage_datagroup_count = 1#[group1] 最后根据自己实际情况，为每一个组添加如下配置group_name=group1storage_server_port=23000store_path_count=1store_path0=/home/fastdfs_storage_data 进入nginx源码的目录（不是编译后生产的目录）：/usr/java/nginx-1.8.0执行命令： 12345678910111213./configure \\--prefix=/usr/local/nginx \\--pid-path=/var/run/nginx/nginx.pid \\--lock-path=/var/lock/nginx.lock \\--error-log-path=/var/log/nginx/error.log \\--http-log-path=/var/log/nginx/access.log \\--with-http_gzip_static_module \\--http-client-body-temp-path=/var/temp/nginx/client \\--http-proxy-temp-path=/var/temp/nginx/proxy \\--http-fastcgi-temp-path=/var/temp/nginx/fastcgi \\--http-uwsgi-temp-path=/var/temp/nginx/uwsgi \\--http-scgi-temp-path=/var/temp/nginx/scgi--add-module=/usr/java/fastdfs-nginx-module/src //XXX为模块存在路径 成功后执行make，重新编译，会生成新的nginx执行文件，不要执行make install，在obj目录下，将obj/nginx复制到旧版本的nginx安装目录下，将旧版本的改为nginx.bak 测试新的nginx程序是否正确，执行/usr/local/nginx/sbin/nginx -t , 若显示以下信息则测试通过 12nginx: theconfiguration file /usr/local/nginx/conf/nginx.conf syntax is oknginx:configuration file /usr/local/nginx/conf/nginx.conf test issuccessful FastDFS设置的lib目录是/usr/local/lib ,所以此时可以有两种方式 123456# 第一种方式，复制一份cp /usr/lib64/libfdfsclient.so /usr/local/lib # 第二种方式，建立软连接（推荐）ln -s /usr/lib64/libfdfsclient.so /usr/local/lib/libfdfsclient.so ln -s /usr/lib64/libfdfsclient.so /usr/lib/libfdfsclient.so 最后需要配置nginx反向代理，进入nginx安装目录，编辑nginx.conf文件，添加server节点： 12345678910111213141516171819server &#123; listen 80; server_name localhost; location /group1/M00 &#123; root /home/fastdfs_storage_data/data; ngx_fastdfs_module; &#125; # location / &#123; # root html; # index index.html index.htm; # &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html81; &#125; &#125; 配置好节点后，依次重启tracker,重启storage，重启nginx，利用上述测试上传图片返回的url，在浏览器中访问，检测是否可以成功访问 5.坑和排坑 我在操作过程中，卡在重新安装nginx这一个步骤很久，启动nginx的时候一直不成功，此时可以通过查看nginx的日志文件来查看错误，这个很重要 编辑nginx.conf文件，添加server节点时，注意监听的端口，80端口只能配置一个 若正常启动了nginx还是不能成功访问图片（图片已经成功上传的情况下），也可以通过查看日志来解决，比如我访问的时候路径里面会带上/html/group1/…等路径，就是因为下面那个默认的location没有注释掉导致的 看日志，很重要 tail -100f /var/log/nginx/error.log 结语 搭这个服务器花了差不多一天的时间。。。过程中难免遇到很多坑，多查资料多百度，文中记录的信息有限，中途说不定也有遗漏的信息，欢迎指正，仅供参考！","tags":[{"name":"Linux","slug":"Linux","permalink":"https://halomelody.github.io/tags/Linux/"},{"name":"FastDFS","slug":"FastDFS","permalink":"https://halomelody.github.io/tags/FastDFS/"}]},{"title":"学习笔记-虚拟机","date":"2017-08-10T07:51:11.000Z","path":"2017/08/10/学习笔记-虚拟机/","text":"内容简介 无论是在工作开发还是学习实践过程中，Linux系统都是不可或缺的，所以不管怎样，虚拟机的存在都是很有必要的，这里主要是记录我安装虚拟机以及CentOs系统的过程，相关的内容在网上有很多，我也是参照其他资料完成的，所以在这里只记录一些关键点和细节，希望对路过的你有帮助^_^. 准备工作1.安装所需 VMware-workstation-full-11.0.0-2305329.exe - 虚拟机安装包（激活秘钥）CentOS-6.4-x86_64-bin-DVD1.iso - CentOs镜像 安装过程1.虚拟机安装 创建文件目录：在相应目录下创建VM/VM_CORE(存放虚拟机安装目录),VM/VM_SHARE(共享虚拟机存放目录)，此步骤按照自己习惯即可 双击进行安装，跟随向导，选项都按照默认即可，选择自定义类型，更改安装路径和共享虚拟机安装路径（按照自己习惯），最后可以将更新和加入体验计划取消掉，最后输入秘钥，永久激活，完成安装 2.CentOs安装 打开VMware，选择创建新的虚拟机 自定义 - next - 稍后安装操作系统 - Linux,CentOs64 - 命名以及选择保存位置（VM/VM_SHARE） - next - 设置内存，根据自己电脑配置设定1G或者2G即可 - next - next - … - 选择磁盘存储为单个文件 - … - 点击自定义硬件，新CD/DVD(IDE)中，选择自定义IOS映像文件，选择CentOS-6.4-x86_64-bin-DVD1.iso - 完成 启动系统，记录之后几个重要的配置点，其他的都默认即可（根据实际情况） 网络配置：选中当前，编辑，勾选前两个，依次输入 XXX.XXX(为虚拟机设置的IP，注意需要与本机处于同一网段，也就是前三个区间保持一致)，本地的子网掩码（255.255.255.0），本地的网关，后面的DNS同 创建分区：/boot 200 , / 10000 , /home 5000 , 剩余空间/swap 4000(内存的2倍) ， 剩余空间/剩余空间。 安装完成后修改网络配置，改为桥接模式，并勾选使用本地配置，启动系统 初始密码用户名为root,密码是自己设置的 登陆后查看IP，尝试与本机互ping，检测网络配置是否成功 网上资料很多，也就没有截图一一记录了，中途有不理解的可以参考网上其他资料 3.虚拟机克隆 右键已经安装好的虚拟机，管理-克隆，一直选择下一步，除了选择创建完整克隆这个选项 克隆完成后的系统IP是一样的，所以需要修改配置，更改IP，可以参考资料 结语 搭这个服务器花了差不多一天的时间。。。过程中难免遇到很多坑，多查资料多百度，文中记录的信息有限，中途说不定也有遗漏的信息，欢迎指正，仅供参考！","tags":[{"name":"Linux","slug":"Linux","permalink":"https://halomelody.github.io/tags/Linux/"},{"name":"VMware","slug":"VMware","permalink":"https://halomelody.github.io/tags/VMware/"},{"name":"CentOs","slug":"CentOs","permalink":"https://halomelody.github.io/tags/CentOs/"}]},{"title":"存储过程--首次尝试","date":"2017-08-06T11:51:11.000Z","path":"2017/08/06/存储过程--首次尝试/","text":"内容简介 上班期间接到一个需要用存储过程完成的需求，由于之前没有接触过存储过程，数据库也仅限于简单使用，所以在此分享sql语句以及一些简单使用，顺便纪念一下第一次写的存储过程语句。有写的不好的地方欢迎大家指正 存储过程1.具体需求 线路对应的费率中的底价改为原来底价的0.9折，四舍五入保留两位小数。 2.分析 分析：相关的表有operation_route – 线路表 , operation_route_revision – 版本记录表 , route_rate – 费率表 ， operation_route_revision作为线路和费率的桥表 首先不能改原来定义的数据和他们的关联关系， 所以 实际操作就是要在原来的基础上 将原来线路对应的 版本–费率 重新生成一份，并且创建新的关联关系 3.思路 遍历op_route 通过该线路关联的 revision_id 对应 op_route_revision 在 对应 route_rate 复制这两条记录，并且做出修改，更新操作.需要修改的字段有： 当前线路的版本号revision_id改为 该线路对应的 版本复制以后的ID 该线路对应的版本中的 费率ID 修改为 对应的 费率更新后的 费率ID 对应费率的 MinPrice 改为 ListPrice*0.9 取小数点后两位 2.具体代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879DELIMITER $$drop procedure if exists `route_rate_update`$$CREATE PROCEDURE `route_rate_update`() BEGIN /* 异常值 */ DECLARE Done INT DEFAULT 0; /* 线路ID */ DECLARE routeId INT; /* 版本ID */ DECLARE revisionId INT; /* 费率ID */ DECLARE rateId INT; /* 复制后的版本ID */ DECLARE newRevisionId INT; /* 复制后的费率ID */ DECLARE newRateId INT; /* 声明op_route表的游标 并查询线路ID，版本ID两个字段值待用 */ DECLARE opRoute CURSOR FOR SELECT op_route_id, revision_id FROM `operation_route` ort where ort.DELETED = 0 and ort.op_route_id in (8,9); /* 异常处理 */ DECLARE CONTINUE HANDLER FOR SQLSTATE &apos;02000&apos; SET Done = 1; /* 打开游标 */ OPEN opRoute; /* 遍历线路表 */ REPEAT /* 逐个取出游标中查询的字段 */ FETCH opRoute INTO routeId, revisionId; /* 如果无异常 */ IF NOT Done THEN /* 逻辑处理 */ -- SELECT routeId; -- SELECT revisionId; /* 复制一条 线路ID对应的版本记录 */ insert into `operation_route_revision` (`op_route_id`, `op_route_name`, ......) select `op_route_id`, `op_route_name`, ......; /* 获取自增版本记录的ID并赋值 */ select last_insert_id() into newRevisionId; /* 查询线路对应的版本同时关联的费率记录ID,并赋值给rateId */ select ortv.RATE_ID from `operation_route_revision` ortv where ortv.REVISION_ID = revisionId into rateId; /* 复制一条 线路对应的版本同时关联的费率记录,对相应的字段进行修改 */ INSERT INTO `route_rate` (`ROUTE_ID`, ...... FROM `route_rate` WHERE `RATE_ID` = rateId ; /* 获取自增费率记录的ID并赋值 */ SELECT LAST_INSERT_ID() INTO newRateId; /* 更新新增的版本记录中的费率ID */ update `operation_route_revision` ortv set ortv.RATE_ID = newRateId where ortv.REVISION_ID = newRevisionId; /* 更新线路中关联的版本记录ID */ UPDATE `operation_route` ort SET ort.revision_id = newRevisionId where ort.op_route_id = routeId; -- select newRevisionId; END IF; /* 循环终止条件 */ UNTIL Done END REPEAT; /* 关闭游标 */ CLOSE opRoute; END$$DELIMITER ; 结语 写的时候，结合网上前辈们的记录，直到最后完成，还是有一点成就感的，或许这就是代码的魅力了……","tags":[{"name":"mysql","slug":"mysql","permalink":"https://halomelody.github.io/tags/mysql/"},{"name":"存储过程","slug":"存储过程","permalink":"https://halomelody.github.io/tags/存储过程/"}]},{"title":"Dubbo--简单介绍和使用（Simple）","date":"2017-08-01T11:31:11.000Z","path":"2017/08/01/Dubbo-简单介绍和使用（Simple）/","text":"内容简介 此篇文章是介绍Dubbo以及它的简单使用，会列举运用spring boot + dubbo搭建项目运用dubbo的步骤，主要是介绍一下dubbo的作用以及简单的配置，若有兴趣的朋友可以继续关注后续的dubbo系列文章，也可以参考官方文档进行学习.个人的一点心得和想法，有错误还请指正。 Dubbo介绍1.什么是Dubbo 一个分布式服务治理框架 2.为什么用Dubbo 官方介绍 当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。 此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键。 自我心得 小项目中dubbo作用不明显，因为项目中的Api都是通过直接依赖调用，当项目庞大比并且服务需要多次重复性的调用时，就需要一个框架来治理，dubbo可以做到的效果就是通多xml文件配置，达到一次提供，到处调用的效果，并且和可以对服务的提供者和消费者进行管理；就是将提供服务的Api打包到服务器，同时注册到注册中心（zookeeper）,需要调用此服务的只需依赖服务器上的jar包，配置消费者服务即可调用Api。 3.基本概念 节点角色说明 provider 服务的提供方 consumer 服用的消费方 registry 注册中心（可以对提供方和消费方统一管理） monitor 统计中心 container 运行容器 调用关系说明: 服务容器负责启动，加载，运行服务提供者。 服务提供者在启动时，向注册中心注册自己提供的服务。 服务消费者在启动时，向注册中心订阅自己所需的服务。 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。 dubbo-provider搭建（Simple）1.准备工作 为了更加直观的体现dubbo的作用，在此我会搭建一个简单的maven项目，通过项目的搭建流程和dubbo的相关简单配置，介绍dubbo的使用，所以，需要做好以下最基本的准备工作： JDK(1.8) 开发工具(IDEA) maven(3.3.9) zookepper(注册中心) 2.项目结构 为了后续代码更好的演示，将两个项目建立在一个工作空间下（IDEA），创建简单的接口和实现类，简单的测试方法，基本结构为： 接口基本实现为：12345678910public interface ISimpleService &#123; public String sayHello(String name);&#125;@Servicepublic class SimpleServiceImpl implements ISimpleService &#123; public String sayHello(String name) &#123; return &quot;Hello&quot; + name; &#125;&#125; 3.spring boot配置 配置项目的pom文件,搭建spring boot运行环境，这里给出一个基本的模板，其中包含mysql的依赖，以及使用基本dubbo的依赖，还有注册中心zookeeper的相关依赖，可以根据实际情况修改： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.2.8.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;artifactId&gt;log4j-over-slf4j&lt;/artifactId&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--dubbo--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;version&gt;2.8.4&lt;/version&gt; &lt;/dependency&gt; &lt;!--zookeeper 相关--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.4.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.1&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;!-- Import dependency management from Spring Boot --&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;1.2.8.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;public&lt;/id&gt; &lt;name&gt;nexus-repository&lt;/name&gt; &lt;url&gt;http://192.168.1.169:8080/nexus/content/groups/public&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;release&lt;/id&gt; &lt;name&gt;nexus-repository&lt;/name&gt; &lt;url&gt;http://192.168.1.169:8080/nexus/content/repositories/releases&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt;&lt;/repositories&gt;&lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;name&gt;nexus-repository&lt;/name&gt; &lt;url&gt;http://192.168.1.169:8080/nexus/content/groups/public/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/pluginRepository&gt;&lt;/pluginRepositories&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 配置完pom文件后还需要配置application.xml(spring默认加载的配置文件，根目录下即可，也可以自己修改配置文件制定)，由于spring boot默认会配置jdbcTemplate，所以需要指定一个dataSourcec(也可通过配置修改，不多说)： 12345678# 制定spring boot运行的端口server.port=8899#db properties 需要指定一个datasourcespring.datasource.url=xxxspring.datasource.username=xxxspring.datasource.password=xxxspring.datasource.driver-class-name=com.mysql.jdbc.Driver 4.dubbo配置 随后配置simple-dubbo-provider.xml，此处我们做最简单的配置：123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;&gt; &lt;!--提供的服务名称 自己指定即可 代表你提供的这个服务--&gt; &lt;dubbo:application name=&quot;simpleprovider&quot;&gt;&lt;/dubbo:application&gt; &lt;!--注册中心 本地启动zookeeper后默认的ip+port--&gt; &lt;dubbo:registry address=&quot;zookeeper://127.0.0.1:2181&quot;&gt;&lt;/dubbo:registry&gt; &lt;!--协议 port自己指定--&gt; &lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;8899&quot;&gt;&lt;/dubbo:protocol&gt; &lt;!--提供的接口服务--&gt; &lt;dubbo:service ref=&quot;simpleServiceImpl&quot; interface=&quot;cn.littledragon.dubbo.service.ISimpleService&quot;&gt;&lt;/dubbo:service&gt; 5.运行函数 最后可以配置日志文件进行，进行日志记录,随后编写main函数运行项目，运用spring boot中写好的main方法，加以修改：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980@SpringBootApplication@ComponentScan(&quot;cn.littledragon&quot;)// @MapperScan(basePackages = &quot;com.tdh.swaptrailer.comm.dal.mapper&quot;)@ImportResource(&quot;simple-dubbo-spring.xml&quot;)public class Application &#123; public static final String CONTAINER_KEY = &quot;dubbo.container&quot;; public static final String SHUTDOWN_HOOK_KEY = &quot;dubbo.shutdown.hook&quot;; private static final Logger LOGGER = LoggerFactory.getLogger(Application.class); private static final ExtensionLoader&lt;Container&gt; LOADER = ExtensionLoader.getExtensionLoader(Container.class); private static volatile boolean running = true; protected static void keepRunning(String[] args) &#123; try &#123; if (args == null || args.length == 0) &#123; String config = ConfigUtils.getProperty(CONTAINER_KEY, LOADER.getDefaultExtensionName()); args = Constants.COMMA_SPLIT_PATTERN.split(config); &#125; final List&lt;Container&gt; containers = new ArrayList&lt;Container&gt;(); for (int i = 0; i &lt; args.length; i++) &#123; containers.add(LOADER.getExtension(args[i])); &#125; LOGGER.info(&quot;Use container type(&quot; + Arrays.toString(args) + &quot;) to run dubbo serivce.&quot;); if (&quot;true&quot;.equals(System.getProperty(SHUTDOWN_HOOK_KEY))) &#123; Runtime.getRuntime().addShutdownHook(new Thread() &#123; public void run() &#123; for (Container container : containers) &#123; try &#123; container.stop(); LOGGER.info(&quot;Dubbo &quot; + container.getClass().getSimpleName() + &quot; stopped!&quot;); &#125; catch (Exception t) &#123; LOGGER.error(t.getMessage(), t); &#125; synchronized (Application.class) &#123; running = false; Application.class.notify(); &#125; &#125; &#125; &#125;); &#125; for (Container container : containers) &#123; container.start(); LOGGER.info(&quot;Dubbo &quot; + container.getClass().getSimpleName() + &quot; started!&quot;); &#125; LOGGER.info(new SimpleDateFormat(&quot;[yyyy-MM-dd HH:mm:ss]&quot;).format(new Date()) + &quot; Dubbo service server started!&quot;); &#125; catch (RuntimeException e) &#123; LOGGER.error(e.getMessage(), e); &#125; synchronized (Application.class) &#123; while (running) &#123; try &#123; Application.class.wait(); &#125; catch (Exception e) &#123; LOGGER.error(e.getMessage(), e); &#125; &#125; &#125; &#125; public static void main(String[] args) throws Exception &#123; // SpringApplication.run(Application.class, args); SpringApplication app = new SpringApplication(Application.class); app.setWebEnvironment(false); app.run(args); keepRunning(args); &#125;&#125; dubbo-consumer搭建 准备工作 在dubbo-provider相同目录下创建dubbo-consumer项目，二者处于同一目录下同一等级 spring boot配置 步骤与dubbo-provider相同，此处多一个步骤就是需要将别人提供的服务（也就是需要使用、消费的服务）引入进来： 12345&lt;dependency&gt; &lt;groupId&gt;cn.littledragon&lt;/groupId&gt; &lt;artifactId&gt;dubbo.provider&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; dubbo配置 随后配置simple-dubbo-provider.xml，此处我们做最简单的配置： 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;&gt; &lt;!-- 服务名称 与提供服务名称对应 --&gt; &lt;dubbo:application name=&quot;simpleprovider&quot;&gt;&lt;/dubbo:application&gt; &lt;!--注册中心--&gt; &lt;dubbo:registry address=&quot;zookeeper://127.0.0.1:2181&quot;&gt;&lt;/dubbo:registry&gt; &lt;!--使用服务 引入依赖后，就可以直接使用此接口 --&gt; &lt;dubbo:reference interface=&quot;cn.littledragon.dubbo.service.ISimpleService&quot; id=&quot;simpleService&quot;/&gt;&lt;/beans&gt; 运行函数 Application.java也与dubbo-provider相同即可 测试函数 编写测试类，测试服务使用情况 123456789101112131415public class ConsumerTest &#123; public static void main(String[] args)&#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[]&#123;&quot;simple-dubbo-spring.xml&quot;&#125;); context.start(); ISimpleService simpleService = (ISimpleService)context.getBean(&quot;simpleService&quot;); System.out.println(simpleService.sayHello(&quot; littledragon ...&quot;)); &#125;&#125; 运行效果 首先本地运行zookepper 运行dubbo-provider项目的Application.main()，打印dubbo started即可 运行dubbo-consumer项目的Application.main()，打印dubbo started即可 运行测试函数.main()，可以看到输出结果：1hello littledragon ... 结语 通过这个例子可以看出，我们在通过提供方提供服务到注册中心，消费方通过配置到注册中心上取到该服务，再进行消费（调用），即可达到不同项目之间的相互调用，也验证了分布式管理的意义，此处只是一个简单的小例子，在实际项目运用中，这种模式加上这个框架的好处会更加明显，后续也会给出关于dubbo其他更深入的运用。","tags":[{"name":"dubbo","slug":"dubbo","permalink":"https://halomelody.github.io/tags/dubbo/"},{"name":"spring boot","slug":"spring-boot","permalink":"https://halomelody.github.io/tags/spring-boot/"}]},{"title":"hexo+github创建个人博客--深入篇","date":"2017-07-23T11:02:11.000Z","path":"2017/07/23/hexo+github创建个人博客--深入篇/","text":"内容简介 此篇文章介绍的是个人博客的一些配置内容，包含博客项目的介绍、主题配置、图床配置以及各种第三方功能插件的使用，若还未搭建个人博客的哥们可以先参考hexo+github创建个人博客–基础篇搭建出自己的个人博客。 hexo项目介绍1.目录结构介绍 .deploy #需要部署的文件 node_modules #Hexo插件 public #生成的静态网页文件 scaffolds #模板 source #博客正文和其他源文件，404、favicon、CNAME 都应该放在这里 _drafts #草稿 _posts #文章 themes #主题 _config.yml #全局配置文件 package.json 2.全局配置文件介绍 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677title: 个人博客 //页面标题subtitle: 玉面小飞龙 //小标题description: 贼溜 //描述author: Little Dragon //作者language: zh-CN //语言timezone: //时区# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: https://halomelody.github.io/ //个人域名root: / //根目录permalink: :year/:month/:day/:title/ //文章创建后生成的目录结构permalink_defaults:# Directory //变量与目录的对应情况source_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace: # Home page setting# path: Root path for your blogs index page. (default = &apos;&apos;)# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator: //分页设置 path: &apos;&apos; per_page: 5 order_by: -date # Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 5pagination_dir: page# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: yilia //主题配置# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: //发布对应的github账号 type: git repo: git@github.com:haloMelody/haloMelody.github.io.git branch: master 主题配置1.主题选择 网上好的主题有很多，可以点击选择，本文介绍的是yilia主题 2.配置主题 从github上下载主题 1git clone https://github.com/litten/hexo-theme-yilia.git 将主题配置到个人博客中，在根目录的全局配置文件中修改此变量（主题项目中也有_config.yml配置文件） 1theme: yilia 主题配置文件介绍（摘要） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384# Header，主题页面显示链接menu: 主页: / 所有文章: /archives# Content# 文章太长，截断按钮文字excerpt_link: more# 文章卡片右下角常驻链接，不需要请设置为falseshow_all_link: &apos;展开全文&apos;# 数学公式mathjax: false# 是否在新窗口打开链接open_in_new: false# 打赏# 打赏type设定：0-关闭打赏； 1-文章对应的md文件里有reward:true属性，才有打赏； 2-所有文章均有打赏reward_type: 1# 打赏wordingreward_wording: 老板大气，谢谢老板！# 支付宝二维码图片地址，跟你设置头像的方式一样。比如：/assets/img/alipay.jpgalipay: http://ou36vgj5u.bkt.clouddn.com/image/blog/alipay.JPG# 微信二维码图片地址weixin: http://ou36vgj5u.bkt.clouddn.com/image/blog/wechatpay.JPG# 目录# 目录设定：0-不显示目录； 1-文章对应的md文件里有toc:true属性，才有目录； 2-所有文章均显示目录toc: 1# 根据自己的习惯来设置，如果你的目录标题习惯有标号，置为true即可隐藏hexo重复的序号；否则置为falsetoc_hide_index: true# 目录为空时的提示toc_empty_wording: &apos;目录，不存在的…&apos;# 是否有快速回到顶部的按钮top: true# Miscellaneous，网站统计baidu_analytics: &apos;24451a8b853bb443019686be21dfdff4&apos;google_analytics: &apos;&apos;favicon: http://ou36vgj5u.bkt.clouddn.com/image/blog/fav.ico#你的头像urlavatar: http://ou36vgj5u.bkt.clouddn.com/image/blog/head.jpg#是否开启分享share_jia: true#评论：1、多说；2、网易云跟帖；3、畅言；4、Disqus 不需要使用某项，直接设置值为false，或注释掉#具体请参考wiki：https://github.com/litten/hexo-theme-yilia/wiki/#1、多说duoshuo: false#2、网易云跟帖wangyiyun: false#3、畅言changyan_appid: falsechangyan_conf: false#4、Disqus 在hexo根目录的config里也有disqus_shortname字段，优先使用yilia的disqus: false#disqus_shortname: halomelody# slider的设置slider: # 是否默认展开tags板块 showTags: true# 智能菜单# 如不需要，将该对应项置为false# 比如#smart_menu:# friends: falsesmart_menu: innerArchive: &apos;文章查找&apos; friends: &apos;友链&apos; aboutme: &apos;关于我&apos; #tagcloud: &apos;标签&apos;#friends:aboutme: little dragon# 页面统计 true为开启#page_count: false# 站点统计 true为开启#site_count: true 弹框配置 首先需要具备hexo中nodeJS版本高于6.2才可以生效（下载最新的nodeJS-&gt;得到的hexo可以即可满足，可以通过hexo -v查看nodeJS版本） 在根目录配置文件中添加如下内容： 123456789101112131415161718jsonContent: meta: false pages: false posts: title: true date: true path: true text: true raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: true 执行清除，生成，其服务等操作查看效果 标签配置 12345title: hexo+github创建个人博客--深入篇tags: - hexo - github - yilia 文章分类 12title: hexo+github创建个人博客--深入篇categories: 瞎搞 目录配置 12title: hexo+github创建个人博客--深入篇toc: true 内容截断 主题配置文件中配置截断显示的文字，excerpt_link: more ,此处显示为more 在文章中键入该注释，即可在该位置生效：1&lt;!-- more --&gt; 相册功能(待实现) github同步本地博客1.提交 在本地配置好个人博客，发布使用后，为防止电脑更换或突发事件导致电脑文件丢失，可以讲博客项目上传至github上保存，需要时再更新到本地即可（此时我们提交的分支为修改后的默认分支–hexo,详细介绍请看hexo+github创建个人博客–基础篇中的仓库设计），提交命令为: 123git add . //将文件加入到提交缓存git commit -m &quot;comment&quot; //添加文件注释git push origin hexo //提交到某分支 提交以后会发现主题文件没有提交上去，是因为此时的主题文件是另一个仓库的git文件，需要将本地主题文件中的.git文件夹删掉，再次提交即可 2.更新 在本地项目中运行命令： 12git pull //更新到本地git status //查看文件对比后的状态 首次更新代码需要执行以下命令(注意不要执行hexo init命令)： 12345git clone xxx //复制github仓库路径npm install hexo //安装插件npm install npm install hexo-deployer-git //发布到git上时必要的插件npm install hexo-server --save //3.0以后server独立出来 需要额外install 其他功能配置1.七牛云图床(供博客图床使用，可选择性进行) 七牛云介绍 挺好的一个云服务网站，注册后可以免费领取10G免费空间等等，可以将博客中需要使用的图片上传到注册的服务器上，可以加快图片的加载速度，至少比在github上的速度快很多。 七牛云账号创建和设置 进入七牛云官网注册，按照流程进行，登陆后选择对象存储，此时可以选择绑定域名(需要已备案)，在内容管理中可以上传图片，复制图片的链接即可在再网页上访问 2.评论功能 第三方的评论插件有很多种，具体介绍可以参考wiki，根据自己的情况选择 yilia主题中已经集成了duoshuo,畅言,网易云跟帖，disqus这几款评论插件，按照提示修改配置文件即可 畅言评论个人觉得比较好用，但是需要填域名备案号，有备案号的朋友可以优先考虑 鉴于此时还没有备案的域名，所以提供另外一个评论插件的配置-来必力 进入来必力，注册，登陆，点击右上角选择管理页面 选择生成一个city版本的评论系统，绑定自己的域名，填写必要信息，最后会生成一份JS代码 在博客项目的…\\themes\\yilia\\layout\\_partial\\post目录下新建livere.ejs文件，将此段代码copy进去，为了方便灵活的管理，进行如下修改： 1data-uid=&quot;&lt;%=theme.livere_uid%&gt;&quot; //将此处的ID配置在主题配置文件中 在主题配置文件中加入： 12livere: true //开启或关闭livere-uid: &apos;your-livere-uid&apos; 最后需要将创建的livere.ejs文件引入到文章中，打开…\\themes\\yilia\\layout\\_partial\\article.ejs文件，在以下位置插入如下代码： 123456789&lt;% if (!index &amp;&amp; post.comments)&#123; %&gt; &lt;% if (theme.livere &amp;&amp; theme.livere_uid)&#123; %&gt; &lt;%- partial(&apos;post/livere&apos;, &#123; key: post.slug, title: post.title, url: config.url+url_for(post.path) &#125;) %&gt; &lt;% &#125; %&gt;&lt;% &#125; %&gt; 生成发布查看效果即可，之后可以通过来必力对评论进行管理，并且可以设置邮箱提醒功能 可以通过在文章md文件中通过comments: false 来关闭某篇文章的评论功能 3.统计功能 yilia主题中集成了google_analytics和baidu_analytics的统计功能，选择一种进行注册，绑定域名即可，但是页面不会有显示的效果，此处，我集成了一个第三方统计插件-不蒜子,按照官网提示操作步骤进行即可，详细如下： 打开\\themes\\yilia\\layout\\_partial目录下的footer.ejs文件，首先最最后copy以下一行代码： 1&lt;script async src=&quot;//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 此处为了方便灵活管理，可以通过配置文件控制显示，选择合适的位置(我选择加在footer.ejs中)，可以加入如下配置： 123456789&lt;div class=&quot;footer-left&quot;&gt;&amp;copy; &lt;%= date(new Date(), &apos;YYYY&apos;) %&gt; &lt;%= config.author || config.title %&gt;&lt;% if (theme.site_count)&#123; %&gt; &lt;span id=&quot;busuanzi_container_site_pv&quot;&gt;本站被踩过&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt;&lt;% &#125; %&gt; &lt;% if (theme.user_count)&#123; %&gt; &lt;span id=&quot;busuanzi_container_site_uv&quot;&gt;被&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人踩过&lt;/span&gt; &lt;% &#125; %&gt; &lt;/div&gt; 预览效果为： 在文章标题后面显示文章的访问量，在\\themes\\yilia\\layout\\_partial下的article.ejs中的以下位置加入： 123456789101112131415&lt;header class=&quot;article-header&quot;&gt; &lt;%- partial(&apos;post/title&apos;, &#123;class_name: &apos;article-title&apos;&#125;) %&gt; &lt;% if (theme.page_count &amp;&amp; !index)&#123; %&gt; &lt;/br&gt; &lt;a class=&quot;article-count-a-tag&quot; href=&quot;javascript:void(0);&quot;&gt; &lt;span class=&quot;icon-sort&quot;&gt;&lt;/span&gt; &lt;span id=&quot;busuanzi_container_page_pv&quot; class=&quot;article-count-a-span&quot;&gt; 被偷看了：&lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt;次 &lt;/span&gt; &lt;/a&gt; &lt;% &#125; %&gt; &lt;% if (!post.noDate)&#123; %&gt; &lt;%- partial(&apos;post/date&apos;, &#123;class_name: &apos;archive-article-date&apos;, date_format: null&#125;) %&gt; &lt;% &#125; %&gt; &lt;/header&gt; 此处有一个小细节就是判断条件中加入 !index 判断条件，在主页时不显示，点击进入某文章时才显示统计的效果，最后还需要在…\\themes\\yilia\\source的main.css中加入自定义的class，我定义的为： 12.article-count-a-tag&#123;color:gray;font-size:14px;&#125; .article-count-a-span&#123;color:#ef7522;font-size:14px;&#125; 最终效果为： (未完待续 ……)","tags":[{"name":"hexo","slug":"hexo","permalink":"https://halomelody.github.io/tags/hexo/"},{"name":"github","slug":"github","permalink":"https://halomelody.github.io/tags/github/"},{"name":"yilia","slug":"yilia","permalink":"https://halomelody.github.io/tags/yilia/"}]},{"title":"hexo+github创建个人博客--基础篇","date":"2017-07-16T12:02:11.000Z","path":"2017/07/16/hexo+github创建个人博客--基础篇/","text":"内容简介 此篇文章介绍的是基础的hexo+github搭建个人博客的方法，包括搭建之前的准备工作和搭建的步骤过程，当最后达到了预期效果，并且想深入研究其他功能时，可以参考hexo+github创建个人博客–深入篇,里面介绍了关于博客的主题，图床，评论，统计等功能的配置和实现。 工具介绍1.hexo介绍 Hexo是一个快速、简洁且高效的博客框架。Hexo使用Markdown解析文章，在几秒内，即可利用靓丽的主题生成静态网页 2.Markdown介绍 Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。 准备工作1.github账号创建和git安装 没有github账号的朋友先进行github账号注册，按照流程注册即可 创建仓库,命名格式为 yourname.git.io,例如我的github名称为haloMelody，仓库名为haloMelody.git.io 为仓库创建两个分支，master（默认的主分支）用于博客的发布，另外创建一个分支hexo（命名看你自己）用于保存博客项目，为了防止换电脑导致以前的博文丢失的情况，确保记录的同步，并且将自己创建的分支hexo设置为默认分支–settings中可进行设置 创建git-pages，一般仓库创建后会自动勾选，此选项可以保证通过已项目名为域名来访问你的博文（有自己域名的可进行域名绑定，参考http://www.cnblogs.com/penglei-it/p/hexo_domain_name.html） 接下来为保证可以在终端运行git命令，需要安装git，下载完成后配置环境变量，将cmd目录配置到path中。 1git version //检测是否安装成功 2.nodejs安装 进入node.js官网安装，按照导航进行 1npm -v //检测nodejs是否安装成功 若出现 命令未找到 的错误提示，则需要手动的配置环境变量，将nodejs目录配到path目录下。此处选择nodejs版本时尽量选择最新的版本，方便后续选择的主题时候的兼容性。 3.hexo安装 nodejs安装成功后可以使用以下命令安装hexo. 123npm install hexo -g //安装全局的hexonpm install hexo //在某目录下有效hexo -v //检测是否成功安装 若出现 命令未找到 的错误提示，则需要手动的配置环境变量，找到hexo的安装目录，全局安装可以参照C:\\Users\\LittleDragon\\AppData\\Roaming\\npm（改为自己电脑的路径），将此路径配置到path中，并且运行hexo -v检测是否成功。 博客搭建1.项目创建 选择一个位置将仓库同步到本地，进入到文件中，打开文件查看选项中的显示影藏文件，可看到至少有一个.git文件（此处将.git文件复制到别处，随后清空仓库项目文件夹，为了后续操作执行–hexo init 的时候需要文件夹为空），同步命令为： 1git clone xxx //复制github仓库路径 随后在此目录下（保证此时是空文件夹），打开CMD（shift+鼠标右键），顺序运行： 123hexo init //初始化项目npm install hexo //安装插件npm install hexo-deployer-git //发布到git上时必要的插件 项目初始化后，可以看到如下的目录结构，分别表示为： .deploy #需要部署的文件 node_modules #Hexo插件 public #生成的静态网页文件 scaffolds #模板 source #博客正文和其他源文件，404、favicon、CNAME 都应该放在这里 _drafts #草稿 _posts #文章 themes #主题 _config.yml #全局配置文件 package.json 接下来可以运行命令，创建一篇博文，文章使用的是MarkDown语言，具体语法此处不做介绍 1hexo new &quot;title&quot; //创建指定标题的文章 文章内容编辑好以后，执行命令： 123hexo clean //清除原有记录hexo g //generate生成html文件hexo s //server本地运行 本地运行以后会实时的对本地文件进行监控，修改后直接刷新浏览器即可看到效果，到此，简单的个人博客已经搭建完成了，接下来可以件博客发布到github上，让网友可以通过你的域名访问个人博客,发布需要的几个步骤： 成功安装了发布需要的插件 1npm install hexo-deployer-git //发布到git上时必要的插件 为你的github配置SSH Key，只需要配置一次，详情请参照github配置SSH Key 在博客项目根目录下的_config.yml中进行如下配置： 1234deploy: type: git repo: git@github.com:yourname/yourname.github.io.git branch: master 执行发布命令，首次可能需要输入github的用户名和密码 1hexo d 发布之后可以登录你的域名查看效果","tags":[{"name":"hexo","slug":"hexo","permalink":"https://halomelody.github.io/tags/hexo/"},{"name":"github","slug":"github","permalink":"https://halomelody.github.io/tags/github/"},{"name":"nodejs","slug":"nodejs","permalink":"https://halomelody.github.io/tags/nodejs/"}]}]